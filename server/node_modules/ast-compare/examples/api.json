{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; compare &#x7D; from \"ast-compare\";\n\n// Find out, does an object/array/string/nested-mix is a subset or equal to another input:\nassert.equal(\n  compare(\n    &#x7B;\n      a: &#x7B;\n        b: \"d\",\n        c: [],\n        e: \"f\",\n        g: \"h\",\n      &#x7D;,\n    &#x7D;,\n    &#x7B;\n      a: &#x7B;\n        b: \"d\",\n        c: [],\n      &#x7D;,\n    &#x7D;\n  ),\n  true\n);"},"compare-arrays.js":{"title":"Compare Arrays","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; compare &#x7D; from \"ast-compare\";\n\nassert.equal(compare([\"a\", \"b\", \"c\"], [\"a\", \"b\"]), true);\n// true, because second is a subset of first\n\nassert.equal(compare([\"a\", \"b\", \"c\"], [\"b\", \"a\"]), false);\n// => false, because order is wrong\n\nassert.equal(compare([\"a\", \"b\"], [\"a\", \"b\", \"c\"]), false);\n// => false, because second is not a subset of first (it's opposite)\n\nassert.equal(\n  compare([&#x7B; a: \"b\" &#x7D;, &#x7B; c: \"d\" &#x7D;, &#x7B; e: \"f\" &#x7D;], [&#x7B; a: \"b\" &#x7D;, &#x7B; c: \"d\" &#x7D;]),\n  true\n);\n// => plain objects nested in arrays"},"compare-objects.js":{"title":"Compare Plain Objects","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; compare &#x7D; from \"ast-compare\";\n\n// Find out, does an object/array/string/nested-mix is a subset or equal to another input:\nassert.equal(compare(&#x7B; a: \"1\", b: \"2\", c: \"3\" &#x7D;, &#x7B; a: \"1\", b: \"2\" &#x7D;), true);\n// true, because second (smallObj) is subset of (or equal) first (bigObj).\n\nassert.equal(compare(&#x7B; a: \"1\", b: \"2\" &#x7D;, &#x7B; a: \"1\", b: \"2\", c: \"3\" &#x7D;), false);\n// => false, because second (smallObj) is not a subset (or equal) to first (bigObj)."},"compare-strings.js":{"title":"Compare Strings","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; compare &#x7D; from \"ast-compare\";\n\nassert.equal(compare(\"a\\nb\", \"a\\nb\"), true);\n\nassert.equal(compare(\"a\", \"b\"), false);"},"opts-hungryForWhitespace.js":{"title":"`opts.hungryForWhitespace`","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; compare &#x7D; from \"ast-compare\";\n\n// by default, key values will be strictly matched using `===`\nassert.equal(\n  compare(\n    &#x7B; a: \"\\n\\n\\n\", b: \"\\t\\t\\t\", c: \"whatever\" &#x7D;,\n    &#x7B; a: \"\\r\\r\\r\", b: \"       \" &#x7D;,\n    &#x7B;\n      hungryForWhitespace: false,\n    &#x7D;\n  ),\n  false\n);\n\n// whitespace is matched leniently with the following option:\nassert.equal(\n  compare(\n    &#x7B; a: \"\\n\\n\\n\", b: \"\\t\\t\\t\", c: \"whatever\" &#x7D;,\n    &#x7B; a: \"\\r\\r\\r\", b: \"       \" &#x7D;,\n    &#x7B;\n      hungryForWhitespace: true,\n    &#x7D;\n  ),\n  true\n);\n\n// the fun doesn't stop here, any \"empty\" structures will be\n// reported as matching:\nassert.equal(\n  compare(\n    &#x7B; a: &#x7B; z: \"\\n\\n\\n\" &#x7D;, b: [\"\\t\\t\\t\"], c: \"whatever\" &#x7D;,\n    &#x7B; a: [[[[[\"\\r\\r\\r\"]]]]], b: &#x7B; c: &#x7B; d: \" \" &#x7D; &#x7D; &#x7D;,\n    &#x7B;\n      hungryForWhitespace: true, // <--- !\n    &#x7D;\n  ),\n  true // <--- !!!\n);\n// \"empty\" thing is:\n//   - string that trims to zero-length\n//   - array with zero or more whitespace strings only\n//   - plain object with zero or more keys with \"empty\" values\n//     (empty arrays, empty plain objects or empty strings)"},"opts-verboseWhenMismatches.js":{"title":"`opts.verboseWhenMismatches`","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; compare &#x7D; from \"ast-compare\";\n\n// by default, returns a boolean without explanation\nassert.equal(\n  compare(\n    &#x7B; a: \"1\", b: \"2\" &#x7D;,\n    &#x7B; a: \"1\", b: \"2\", c: \"3\" &#x7D;,\n    &#x7B;\n      verboseWhenMismatches: false, // <---\n    &#x7D;\n  ),\n  false\n);\n\nassert.equal(\n  compare(\n    &#x7B; a: \"1\", b: \"2\" &#x7D;,\n    &#x7B; a: \"1\", b: \"2\", c: \"3\" &#x7D;,\n    &#x7B;\n      verboseWhenMismatches: true, // <---\n    &#x7D;\n  ),\n  'The given object has key \"c\" which the other-one does not have.'\n);\n\n// when opts.verboseWhenMismatches is enabled, a negative result is\n// string (explanation). A positive result is boolean \"true\".\nassert.equal(\n  compare(\n    &#x7B; a: \"1\", b: \"2\" &#x7D;,\n    &#x7B; a: \"1\", b: \"2\" &#x7D;,\n    &#x7B;\n      verboseWhenMismatches: true, // <---\n    &#x7D;\n  ),\n  true\n);"}}