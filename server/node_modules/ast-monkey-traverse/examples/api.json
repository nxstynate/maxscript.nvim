{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; traverse &#x7D; from \"ast-monkey-traverse\";\n\nconst paths = [];\nconst source = &#x7B;\n  a: &#x7B;\n    foo: &#x7B;\n      bar: [\n        &#x7B;\n          foo: \"c\",\n        &#x7D;,\n      ],\n      d: &#x7B;\n        e: &#x7B;\n          foo: \"f\",\n        &#x7D;,\n      &#x7D;,\n    &#x7D;,\n  &#x7D;,\n&#x7D;;\n\ntraverse(source, (key, val, innerObj) => &#x7B;\n  // if currently an object is traversed, you get both \"key\" and \"val\"\n  // if it's array, only \"key\" is present, \"val\" is undefined\n  const current = val !== undefined ? val : key;\n  if (\n    // it's object (not array)\n    val !== undefined &&\n    // and has the key we need\n    key === \"foo\"\n  ) &#x7B;\n    // push the path to array in the outer scope\n    paths.push(innerObj.path);\n  &#x7D;\n  return current;\n&#x7D;);\n\n// notice object-path notation \"a.foo.bar.0.foo\" - array segments use dots too:\nassert.deepEqual(paths, [\"a.foo\", \"a.foo.bar.0.foo\", \"a.foo.d.e.foo\"]);"},"compatible-with-object-path.js":{"title":"Compatible With `object-path`","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport op from \"object-path\";\nimport &#x7B; traverse &#x7D; from \"ast-monkey-traverse\";\n\nconst input = &#x7B; a: \"1\", b: [&#x7B; c: \"2\" &#x7D;] &#x7D;;\nObject.freeze(input); // let's freeze it, just for fun\nconst result1 = [];\n\n// the full traversal would look like this:\ntraverse(input, (key1, val1, innerObj) => &#x7B;\n  const current = val1 !== undefined ? val1 : key1;\n  result1.push(innerObj.path);\n  return current;\n&#x7D;);\n\n// notice the object-path notation is \"b.0.c\" not \"b[0].c\"\nassert.deepEqual(result1, [\"a\", \"b\", \"b.0\", \"b.0.c\"]);\n\n// each reported path is fully compatible with `object-path` get() method\nassert.deepEqual(op.get(input, \"a\"), \"1\");\nassert.deepEqual(op.get(input, \"b\"), [&#x7B; c: \"2\" &#x7D;]);\nassert.deepEqual(op.get(input, \"b.0\"), &#x7B; c: \"2\" &#x7D;);\nassert.deepEqual(op.get(input, \"b.0.c\"), \"2\");"},"stopping.js":{"title":"Stop","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; traverse &#x7D; from \"ast-monkey-traverse\";\n\nconst input = &#x7B; a: \"1\", b: &#x7B; c: \"2\" &#x7D; &#x7D;;\nconst result1 = [];\n\n// the full traversal would look like this:\ntraverse(input, (key1, val1, innerObj) => &#x7B;\n  const current = val1 !== undefined ? val1 : key1;\n  result1.push(innerObj.path);\n  return current;\n&#x7D;);\nassert.deepEqual(result1, [\"a\", \"b\", \"b.c\"]);\n\n// now let's stop the traversal at path \"b\" (that's real\n// path, how object-path would reference it)\nconst result2 = [];\ntraverse(input, (key1, val1, innerObj, stop) => &#x7B;\n  const current = val1 !== undefined ? val1 : key1;\n  result2.push(innerObj.path);\n  if (innerObj.path === \"b\") &#x7B;\n    stop.now = true; // <---------------- !!!!!!!!!!\n  &#x7D;\n  return current;\n&#x7D;);\nassert.deepEqual(result2, [\"a\", \"b\"]);"}}